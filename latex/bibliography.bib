@book{nielsen1999analysis,
  title     = "Principles of Program Analysis",
  author    = "Nielson, Flemming and Nielson, Hanne Riis and Hankin, Chris",
  publisher = "Springer Berlin",
  address   = "Heidelberg, Germany",
  year      = 2014,
  edition   = "1st",
  isbn      = "978-3-540-65410-0",
  doi       = "10.1007/978-3-662-03811-6"
}
@inproceedings{augustsson1999intrinsic,
  title     = "An exercise in dependent types: A well-typed interpreter",
  author    = "Augustsson, Lennart and Carlsson, Magnus",
  booktitle = "Workshop on Dependent Types in Programming",
  location  = "Gothenburg",
  year      = 1999
}
@phdthesis{chapman2009type,
  title   = "Type checking and normalisation",
  author  = "Chapman, James Maitland",
  advisor = "Altenkirch, Thorsten",
  school  = "University of Nottingham",
  year    = 2009
}
@phdthesis{norell2007agda,
  title   = "Towards a practical programming language based on dependent type theory",
  author  = "Norell, Ulf",
  advisor = "Jansson, Patrik",
  school  = "Chalmers University of Technology",
  year    = 2007
}
@article{bove2016recursion,
  title     = "Partiality and Recursion in Interactive Theorem Provers – An Overview",
  author    = "Bove, Ana and Krauss, Alexander and Sozeau, Matthieu",
  journal   = "Mathematical Structures in Computer Science",
  publisher = "Cambridge University Press",
  volume    = 26,
  number    = 1,
  DOI       = "10.1017/S0960129514000115",
  year      = 2016,
  pages     = "38–88"
}
@article{allais2018universe,
author = {Allais, Guillaume and Atkey, Robert and Chapman, James and McBride, Conor and McKinna, James},
title = {A Type and Scope Safe Universe of Syntaxes with Binding: Their Semantics and Proofs},
year = {2018},
issue_date = {September 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {2},
number = {ICFP},
url = {https://doi.org/10.1145/3236785},
doi = {10.1145/3236785},
abstract = {Almost every programming language’s syntax includes a notion of binder and corresponding bound occurrences, along with the accompanying notions of α-equivalence, capture avoiding substitution, typing contexts, runtime environments, and so on. In the past, implementing and reasoning about programming languages required careful handling to maintain the correct behaviour of bound variables. Modern programming languages include features that enable constraints like scope safety to be expressed in types. Nevertheless, the programmer is still forced to write the same boilerplate over again for each new implementation of a scope safe operation (e.g., renaming, substitution, desugaring, printing, etc.), and then again for correctness proofs. We present an expressive universe of syntaxes with binding and demonstrate how to (1) implement scope safe traversals once and for all by generic programming; and (2) how to derive properties of these traversals by generic proving. Our universe description, generic traversals and proofs, and our examples have all been formalised in Agda and are available in the accompanying material. NB. we recommend printing the paper in colour to benefit from syntax highlighting in code fragments.},
journal = {Proc. ACM Program. Lang.},
month = {jul},
articleno = {90},
numpages = {30},
keywords = {Semantics, Simulation, Logical Relations, Generic Programming, Agda, Fusion, Syntax with Binding}
}
@article{pickard2021calculating,
author = {Pickard, Mitchell and Hutton, Graham},
title = {Calculating Dependently-Typed Compilers (Functional Pearl)},
year = {2021},
issue_date = {August 2021},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {5},
number = {ICFP},
url = {https://doi.org/10.1145/3473587},
doi = {10.1145/3473587},
abstract = {Compilers are difficult to write, and difficult to get right. Bahr and Hutton recently developed a new technique for calculating compilers directly from specifications of their correctness, which ensures that the resulting compilers are correct-by-construction. To date, however, this technique has only been applicable to source languages that are untyped. In this article, we show that moving to a dependently-typed setting allows us to naturally support typed source languages, ensure that all compilation components are type-safe, and make the resulting calculations easier to mechanically check using a proof assistant.},
journal = {Proc. ACM Program. Lang.},
month = {aug},
articleno = {82},
numpages = {27},
keywords = {program calculation, dependent types}
}
