\documentclass[sigplan,nonacm,screen,review,timestamp]{acmart}

% https://icfp22.sigplan.org/home/tyde-2022#Call-for-Papers

\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{stmaryrd}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{xspace}
\usepackage{natbib}
\usepackage{todonotes} % TODO: remove at the end

\citestyle{acmauthoryear}

\newcommand{\Draft}[1]{{\color{gray} - #1}}
%\newcommand{\Todo}[1]{}
\newcommand{\Todo}[1]{\todo[inline]{TODO: #1}}

\newcommand{\I}[1]{\texttt{#1}\xspace}
\newcommand{\K}[1]{\textbf{\texttt{#1}}\xspace}
\newcommand{\U}{\texttt{U}\xspace}
\newcommand{\Expr}{\texttt{Expr}\xspace}
\newcommand{\Ctx}{\texttt{Ctx}\xspace}
\newcommand{\Env}{\texttt{Env}\xspace}
\newcommand{\Interpret}[1]{\llbracket #1 \rrbracket\xspace}
\newcommand{\Floor}[1]{\lfloor #1 \rfloor\xspace}
\newcommand{\Existential}[2]{\Sigma[ #1 \in #2 ]\xspace}

\title{Provingly Correct Optimisations on Intrinsically Typed Expressions}
\subtitle{Extended Abstract}

% TODO: does this make sense?
% \keywords{dependent types, agda, compiler, type safety, program optimisation}

\author{Matthias Heinzel}
\affiliation{%
  \institution{Utrecht University}
  \city{Utrecht}
  \country{Netherlands}}
\email{m.h.heinzel@students.uu.nl}

\acmConference[TyDeâ€™22]{Workshop on Type-Driven Development}{September 11}{Ljubljana, Slovenia}

\date{\today}

\begin{document}

\maketitle

\section{Introduction}

When writing a compiler for a functional programming language,
one of the core considerations usually is the treatment of binders and variables.
\Draft{many possible representations (string, de Bruijn)}
\Draft{naive implementation is not scope-safe, therefore partial}

A well-known technique when using dependently typed programming languages such as Agda
\cite{norell2007agda}
is to define an intrinsically typed syntax tree \cite{augustsson1999intrinsic}.
\Draft{correct by construction, scope- and type-safe, total evaluator}
This construction has featured in several papers exploring
basic operations like renaming and substitution
\cite{allais2018universe}
as well as compilation to different target languages
\cite[supplemental material]{pickard2021calculating}.

However, there has been little focus on performing optimisations on the syntax tree.
\Draft{optimisations are important, correctness often not trivial}

While the search for optimisation opportunities is mostly unaffected
by the presence of additional type information,
performing any transformation of the program now comes with the burden of
convincing the compiler of its type- and scope-safety.
\Draft{especially when related to binders}
\Draft{also, analysis results need to be in form that allows proving correctness}

For any given set of language features, there is a large number of potentially relevant optimisations.
We will consider a simple expression language with let-bindings,
making the optimisations widely applicable.
% \Todo{Not sure how to plug the Nielsen book here, maybe just leave it out}
% \Todo{This reads a bit awkwardly, maybe there's a better justification.}
% list interesting optimisations?

In this paper, we \ldots\ set of analyses \ldots\ 
As a specific instance, we present an implementation of \emph{dead binding elimination}
by defining a syntax tree annotated with variable usage information.
We further show that the optimisation is semantics-preserving,
independently of how the annotations are obtained.
\Todo{
  The last bit does not seem clear.
  In LVA, the annotated expression type is expressive enough
  that the definition of \I{analyse} is basically forced,
  but generally it could have more freedom, e.g. to use heuristics for inlining,
  and its implementation would not matter for optimisation correctness.
}


\section{Dead Binding Elimination}

\subsection{Intrinsically Typed Expressions with Binders}

We define a simple typed expression language with binding.
Instead of freely allowing function values to be created (using $\lambda$-abstraction) and applied,
variables are introduced using let-bindings.
This keeps the language first-order and simplifies parts of the analysis.

Since the optimisations we are interested in relate to variables and binders only,
the choice of possible values and additional primitive operations on them is mostly arbitrary.
For simplicity, we choose the values in our language to be natural numbers or Booleans
and include addition as an example of a binary operator.

\Todo{Is the above all relevant? Shorten?}

\Todo{Show Agda definition of $\Expr$?}

In Agda, the type of expressions $\Expr$ is indexed by its return type ($\tau : \U$)
and \emph{context} ($\Gamma : \Ctx$).
Each free variable is a de Bruijn index into the context and acts as a proof that
the context contains an element of the matching type.
This allows the definition of a total evaluator
using a matching \emph{environment}:

\begin{align*}
  \I{eval} &: \I{Expr}\ \Gamma\ \tau \to \I{Env}\ \Gamma \to \Interpret{\tau}
\end{align*}
%(\texttt{eval : Expr $\Gamma$ $\tau$ $\to$ Env $\Gamma$ $\to$ $\Interpret{\tau}$}).
%($\texttt{eval} : \Expr \Gamma \tau \to \Env \Gamma \to \Interpret{\tau}$).

\subsection{Sub-contexts}

Note that an expression is not forced to make use of the whole context it has access to.
Specifically, a let-binding introduces a new element into the context, but it might never be used.

\Todo{cite \emph{A correct-by-construction conversion to combinators}? It's quite similar.}

To reason about the \emph{sub-contexts} of a context that are live (actually used),
we use \emph{order-preserving embeddings} (OPE) \cite{chapman2009type}.

\begin{align*}
  &\K{data}\ \I{Subset} : \I{Ctx} \to \I{Set}\ \K{where}          \\
  &\ \ \ \ \I{Empty} : \I{Subset}\ []                                    \\
  &\ \ \ \ \I{Drop}  : \I{Subset}\ \Gamma \to \I{Subset}\ (\tau :: \Gamma)  \\
  &\ \ \ \ \I{Keep}  : \I{Subset}\ \Gamma \to \I{Subset}\ (\tau :: \Gamma)
\end{align*}

Such a sub-context describe a context themselves
($\Floor{\_} : \I{Subset}\ \Gamma \to \I{Ctx}$),
but contains more information than that.
For example, the witnesses of a binary relation $\subseteq$ on sub-contexts are unique,
as opposed to e.g. $[\I{INT}] \subseteq [\I{INT}, \I{INT}]$.

From now on, we will only consider expressions
$\I{Expr}\ \Floor{\Delta}\ \tau$ in some sub-context $\Delta : \I{Subset}\ \Gamma$.
Initially, we take $\Delta = \I{all}\ \Gamma$ to be the complete sub-context of the original context.

\subsection{Live Variable Analysis}

Now we can annotate each expression with its \emph{live variables},
the sub-context $\Delta' \subseteq \Delta$ that is really used.
To that end, we define annotated expressions $\I{LiveExpr}\ \Delta\ \Delta'$.
While $\Delta$ is treated as before, $\Delta'$ now only contains live variables,
starting with the variables, where it forms a singleton sub-context.

\begin{align*}
  \K{data}\ \I{LiveExpr}& : (\Delta\ \Delta' : \I{Subset}\ \Gamma) (\tau : \I{U}) \to Set\ \K{where} \\
  \I{Let}
    :\ &\I{LiveExpr}\ \Delta\ \Delta_1\ \sigma \to  \\
       &\I{LiveExpr}\ (\I{Keep}\ \Delta)\ \Delta_2\ \tau \to  \\
       &\I{LiveExpr}\ \Delta\ (\Delta_1 \cup \I{pop}\ \Delta_2)\ \tau \\
  \ldots&
\end{align*}

\begin{align*}
  \I{analyse}
    &:  \I{Expr}\ \Floor{\Delta}\ \tau
    \to \Existential{\Delta'}{\I{Subset}\ \Gamma}\ \I{LiveExpr}\ \Delta\ \Delta'\ \tau \\
  \I{forget}
    &:  \I{LiveExpr}\ \Delta\ \Delta'\ \tau
    \to \I{Expr}\ \Floor{\Delta}\ \tau
\end{align*}

The only requirement on \I{analyse} we have is that we can forget the annotations again,
with $\I{forget} \circ \I{analyse} \equiv \I{id}$.

\subsection{Transformation}

Note that we can evaluate $\I{LiveExpr}$ directly, with the main difference
that in the $\I{Let}$-case we match on $\Delta_2$ to distinguish whether the bound variable is live.
If it is not, we directly evaluate the body, ignoring the bound declaration.
This \emph{optimised semantics} shows that we can do a similar program transformation
and will be useful in its correctness proof.

\begin{align*}
  \I{dbe}
    &:  \I{LiveExpr}\ \Delta\ \Delta'\ \tau
    \to \I{Expr}\ \Floor{\Delta'}\ \tau
\end{align*}

\Todo{
  Not sure if and how to show code here.
  It's a bit verbose with the pattern matching on $\Delta_1$ and $\Delta_2$ and \I{injExpr}.
}
\Todo{
  Mention renamings (\I{injExpr}) that are necessary.
}

\subsection{Correctness}

We want to show that dead binding elimination preserves semantics:
$\I{eval} \circ \I{dbe} \circ \I{analyse} \equiv \I{eval}$.
Since we know that $\I{forget} \circ \I{analyse} \equiv \I{id}$,
it is sufficient to show the following:

\begin{align*}
  \I{eval} \circ \I{dbe} \equiv \I{eval} \circ \I{forget}
\end{align*}

The proof gets simpler if we split it up using the optimised semantics.

\begin{align*}
  \I{eval} \circ \I{dbe} \equiv \I{evalLive} \equiv \I{eval} \circ \I{forget}
\end{align*}

\Todo{details about proof statement, generalisation of environment used etc.}

Both proofs work inductively on the expression, with most cases being a straight-forward congruence.
The interesting case is \I{Let}, \ldots

\Todo{continue}

\subsection{Iterating the Optimisation}

% When we remove a binding that contains the only occurrences of some other variable,
% we can run the optimisation again to remove that binding as well.
% This is common among optimisations, which then can be iteratively applied until a fixpoint is reached.
% Sometimes (as with \emph{strong live variable analysis} here)
% it is possible to achieve the same result in a single pass,
% but at the cost of additional complexity.

A removed binding can contain the only occurrences of some other variable.
This makes another binding dead, allowing further optimisation when running the algorithm again.
While in our simple setting all these bindings could be identified in a single pass
using \emph{strong live variable analysis},
in general it can be useful to simply iterate the optimisation until a fixpoint is reached.

Such an iteration is not structurally recursive, so Agda's termination checker needs our help.
We observe that the algorithm must terminate
since the number of bindings decreases with each iteration (but the last) and cannot become negative.
To convince the termination checker, we use \emph{well-founded recursion} \cite{bove2016recursion}
on the number of bindings.

The correctness follows directly from the correctness of each individual iteration step.

\section{Preliminary Results}
\Todo{Conclude, other possible optimisations, more complex language?}

\bibliographystyle{ACM-Reference-Format}
\bibliography{bibliography}{}

\end{document}
