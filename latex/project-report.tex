\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{stmaryrd}
\usepackage{listings}
\usepackage[pdftex]{xcolor}
\usepackage{agda}
\usepackage{cite}

\usepackage{newunicodechar}
\newunicodechar{∀}{\ensuremath{\mathnormal\forall}}
\newunicodechar{⊤}{\ensuremath{\mathnormal\top}}
\newunicodechar{⊥}{\ensuremath{\mathnormal\bot}}
\newunicodechar{≡}{\ensuremath{\mathnormal\equiv}}
\newunicodechar{ᵇ}{\ensuremath{\mathnormal{}^b}}
\newunicodechar{ℕ}{\ensuremath{\mathnormal\mathbf{N}}}
\newunicodechar{∅}{\ensuremath{\mathnormal\emptyset}}
\newunicodechar{⊆}{\ensuremath{\mathnormal\subseteq}}
\newunicodechar{∪}{\ensuremath{\mathnormal\cup}}
\newunicodechar{∷}{\ensuremath{\mathnormal::}}
\newunicodechar{⟦}{\ensuremath{\mathnormal\llbracket}}
\newunicodechar{⟧}{\ensuremath{\mathnormal\rrbracket}}
\newunicodechar{⌊}{\ensuremath{\mathnormal\lfloor}}
\newunicodechar{⌋}{\ensuremath{\mathnormal\rfloor}}
\newunicodechar{Γ}{\ensuremath{\mathnormal\Gamma}}
\newunicodechar{σ}{\ensuremath{\mathnormal\sigma}}
\newunicodechar{τ}{\ensuremath{\mathnormal\tau}}
\newunicodechar{Δ}{\ensuremath{\mathnormal\Delta}}
\newunicodechar{₁}{\ensuremath{\mathnormal{}_1}}
\newunicodechar{₂}{\ensuremath{\mathnormal{}_2}}

\include{generated/Lang}
\include{generated/Subset}
\include{generated/Recursion}
\include{generated/Live}

\title{Provingly Correct Optimizations in an Intrinsically Typed Compiler\\
  \vspace{1cm}
  \large Experimentation Project Report}
\author{Matthias Heinzel (1632256)}
\date{\today}

\begin{document}

\maketitle
\tableofcontents

% TODO: consistently use british spelling

\section{Introduction}
% ?
% Agda
% others worked on compilation of intrinsically typed AST
% but not a lot on optimizations in this setting
% handling bindings in a way the compiler accepts requires some care


\section{A Simple Expression Language}

\subsection{Expressions with Bindings}

We define a simple typed expression language with bindings.
Since the optimizations we are interested in relate to variables and bindings only,
the choice of values and primitive operations on them is mostly arbitrary.
For simplicity, we choose values $v$ in our language to be natural numbers or Booleans
and include addition as an example of a binary operator.
Extending the language with further values and operators is trivial.

Expressions can be bound to a variable $v$ using the $\textbf{let}$ construction.
This gives us a language similar to the simply typed $\lambda$-calculus,
with $\textbf{let } x = P \textbf{ in } Q$ corresponding to $(\lambda x. Q) P$.
Forcing $\lambda$-abstraction and application to occur together
simplifies parts of the analysis and
avoids the need for functions as values.

\begin{align*}
  P, Q ::=&\ v
  \\ \big|&\ P + Q
  \\ \big|&\ \textbf{let } x = P \textbf{ in } Q
  \\ \big|&\ x
\end{align*}

% TODO: say something generally about open/closed terms and de Bruijn indices?

\subsection{Intrinsically Typed Syntax Trees}
% now in Agda!
% some representations are error-prone/partial
% representation correct by construction
% similar to ... (TODO: reference)

\CodeLangTypes

% open/closed terms

\CodeLangCtx

% de Bruijn (TODO: reference)

\CodeLangRef

\CodeLangExpr

% allows semantics to be total

\CodeLangSemantics


\section{Live Variable Analysis}
% want to annotate terms with variables actually used
% then remove unused bindings

\subsection{Subsets of a Context}
% order preserving embedding
\cite{chapman2009type}
% why this representation?
%   subset relation/proof on Subsets is unique (compare e.g. [NAT] \subseteq [NAT, NAT]
%   union-like operation is definable

\CodeSubsetSubset
\CodeSubsetOpSubseteq

\subsection{Analysis}
% a lot is encoded in the annotated LiveExpr type

\CodeLiveExpr

\subsection{Correctness}
% relate by evaluation
% split the proof
% subtlety: evaluate under which environment
% subtlety: irrelevant arguments

\subsection{Iterating the Analysis}
% optimization might make other bindings unused
% could be done in one pass here, but gets complex
% => take a fixpoint! termination?
% Well-Founded recursion


\section{Further Work}

\subsection{Extending the Language}
% Lam+App, short sketch
% recursion
% data types (product/sum)
% pointers?

\subsection{Other Analyses}
% inlining
%   more difficult to encode goal, take list of what to inline
% move bindings to top or as far down as possible

\bibliographystyle{plain}
\bibliography{bibliography}{}

\end{document}
