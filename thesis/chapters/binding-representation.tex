\chapter{Binding Representation}
\label{ch:binding-representation}

\section{Explicit names}
\label{sec:binding-representation-names}
The syntax specified above treats variables as letters, or more generally strings,
and one can use the same representation inside a compiler.
While this is how humans usually write programs, it comes with several downsides.
For example, additional work is necessary
if we want the equality of expressions to be independent of the specific variable names chosen
(\emph{$\alpha$-equivalence}).
Also, there are pitfalls like variable shadowing and variable capture during substitution,
requiring the careful application of variable renamings
\cite{Barendregt1985LambdaCalculus}.

There have been multiple approaches to help compiler writers maintain the relevant invariants,
such as GHC's rapier \cite{Jones2002GHCInliner},
but these are generally still error-prone
\cite{Maclaurin2022Foil}.

\section{de Bruijn Indices}
\label{sec:binding-representation-de-bruijn}

With \emph{de Bruijn indices}
\cite{DeBruijn1972NamelessIndices},
we instead adopt a \emph{nameless} representation.
Each variable is represented as a natural number,
counting the number of nested bindings between variable occurrence and its binding:
$\DeBruijn{0}$ refers to the innermost binding, $\DeBruijn{1}$ to the next-innermost etc.
If we adapt the syntax for let-bindings to omit the unnecessary variable name,
the example expression from dead binding elimination is represented as follows:
\Fixme{Numbered examples/figures to make reference clearer?}

\begin{align*}
  &\LetB 42 \In                       \\
  &\ \ \LetB \DeBruijn{0} + 6 \In     \\
  &\ \ \ \ \LetB \DeBruijn{0} + 7 \In \\
  &\ \ \ \ \ \ \DeBruijn{2}
\end{align*}

This makes $\alpha$-equivalence of expressions trivial and avoids variable capture,
but there are still opportunities for mistakes during transformations.
Adding or removing a binding
requires us to traverse the binding's body and add or subtract 1 from all its free variables.
We can see this in our example when removing the innermost (unused) let-binding:

\begin{align*}
  &\LetB 42 \In                   \\
  &\ \ \LetB \DeBruijn{0} + 6 \In \\
  &\ \ \ \ \DeBruijn{1}
\end{align*}

While useful for machines, this representation can be unintuitive for humans to reason about.
This can be alleviated by formally describing the necessary invariants
and using tooling to make sure they are upheld.
We show a possible way of using dependent types to do this in section
\ref{sec:de-bruijn-intrinsically-typed}.

\section{co-de-Bruijn Representation}
\label{sec:binding-representation-co-de-bruijn}

Another nameless representation is described by McBride \cite{McBride2018EveryBodysGotToBeSomewhere}.
Where de Bruijn representation uses references to indicate which of the variables in scope they refer to,
the co-de-Bruijn way is for each syntax tree node
to shrink down the context of which variables occur in each subexpression.
Once a variable occurrence is reached, the context only consists of a single element.
Introducing or removing a binding can now be done without traversing the expression,
as we can instead modify the way the context is shrunk down to its \emph{relevant}
(actually occurring) part.
We will see further advantages of the co-de-Bruijn approach later.

This representation and its invariants can be even harder for humans to comprehend.
McBride writes that
``only a fool would attempt to enforce the co-de-Bruijn invariants without support
from a typechecker''
and makes heavy use of Agda's dependent type system.
We follow his approach closely, as shown in section
\ref{sec:co-de-bruijn-intrinsically-typed}.

\section{Other Representations}
\label{sec:binding-representation-other}

There are many other techniques%
\footnote{
There is an introductory blogpost
\cite{Cockx2021RepresentationsBinding}
comparing options available in Agda.
}
such as higher-order abstract syntax
\cite{Pfenning1988HOAS}
and also combinations of multiple techniques, e.g. the locally nameless representation
\cite{Chargueraud2011LocallyNameless}.
