\chapter{Preliminaries}
\label{ch:preliminaries}
  \Draft{
    As a running example, we will consider a simple expression language with let-bindings,
    variables, primitive values (integers and Booleans), and a few binary operators.
    Since the transformations in this thesis primarily relate to variables and binders,
    the choice of possible values and additional primitive operations on them is mostly arbitrary.
    Extending the language with further values and operators is trivial.
    \begin{align*}
      P, Q ::=&\ v
      \\ \big|&\ P + Q
      \\ \big|&\ \Let{x} P \In Q
      \\ \big|&\ x
    \end{align*}

    An expression can be bound to a variable $x$ using a $\textbf{let}$-binding.
    Note that this makes the language equivalent to a restricted version of the simply typed $\lambda$-calculus,
    where $\lambda$-abstraction and application can only occur together as $(\lambda x. Q)\ P$.
    Encapsulating this pattern as $\Let{x} P \In Q$
    simplifies parts of the analysis and
    avoids the need for allowing functions as values.
    \Fixme{We now have $\lambda$-abstractions!}
  }

\section{Program Analysis and Transformation}
\label{sec:program-transformations}
    For now we mainly consider transformations aimed at optimising functional programs.
    A large number of program analyses and optimisations are presented in the literature
    \cite{Nielson1999PrinciplesProgramAnalysis}
    \cite{Santos1995CompilationByTransformation}
    and used in production compilers such as the Glorious Haskell Compiler (GHC).
    We generally focus on those transformations that deal with variable binders,
    such as
    \emph{inlining},
    \emph{let-floating},
    \emph{common subexpression elimination} and
    \emph{dead binding elimination},
    which is explained below.
  \paragraph{Dead Binding Elimination}
    An expression is not forced to make use of the whole context to which it has access.
    Specifically, a let-binding introduces a new variable, but it might never be used
    in the body.
    Consider for example the following expression:
    \begin{align*}
      &\Let{x} 42 \In            \\
      &\ \ \Let{y} x + 6 \In     \\
      &\ \ \ \ \Let{z} y + 7 \In \\
      &\ \ \ \ \ \ x
    \end{align*}
    Here, the binding for $z$ is clearly unused, as the variable never occurs in the body.
    Such dead bindings can be identified by \emph{live variable analysis}
    and consequently be removed.
    \\
    Note that $y$ is not needed either: Removing $z$ will make $y$ unused.
    Therefore, multiple iterations of live variable analysis and binding elimination might be required.
    Alternatively, \emph{strongly live variable analysis} can achieve the same result in a single pass
    by only considering variables to be live
    if they are used in declarations of variables that are live themselves.
  \paragraph{Moving let-bindings}
    Even when a binding cannot be removed,
    it can still be beneficial to move it to a different location.
    Several such strategies have for example been described and evaluated
    in the context of lazy functional programs
    \cite{Jones1996LetFloating}.
    \\
    Of those, we will focus on the \emph{let-sinking} transformation
    (called let-floating in the paper).
    Generally, the further inward a let binding is moved, the better:
    Further optimisations might get unlocked and in the presence of branching,
    the binding it might never be executed.
    Of course, we must be careful that the binding remains in scope
    for all of the variable's occurrences
    and consider some exceptions to the heuristic of pushing as far as possible.
    We do not want to duplicate the binding
    or move it inside a $\lambda$-abstraction, which duplicates work
    if evaluated multiple times.

\section{Binding Representations}
\label{sec:binding-representations}
  \paragraph{Explicit names}
    The syntax specified above treats variables as letters, or more generally strings,
    and one can use the same representation inside a compiler.
    While this is how humans usually write programs, it comes with several downsides.
    For example, additional work is necessary
    if we want the equality of expressions to be independent of the specific variable names chosen
    (\emph{$\alpha$-equivalence}).
    Also, there are pitfalls like variable shadowing and variable capture during substitution,
    requiring the careful application of variable renamings
    \cite{Barendregt1985LambdaCalculus}.

    There have been multiple approaches to help compiler writers maintain the relevant invariants,
    such as GHC's rapier \cite{Jones2002GHCInliner},
    but these are generally still error-prone
    \cite{Maclaurin2022Foil}.

  \paragraph{de Bruijn Indices}
    With \emph{de Bruijn indices}
    \cite{DeBruijn1972NamelessIndices},
    we instead adopt a \emph{nameless} representation.
    Each variable is represented as a natural number,
    counting the number of nested bindings between variable occurrence and its binding:
    $\DeBruijn{0}$ refers to the innermost binding, $\DeBruijn{1}$ to the next-innermost etc.
    If we adapt the syntax for let-bindings to omit the unnecessary variable name,
    the example expression from dead binding elimination is represented as follows:
    \Fixme{Numbered examples/figures to make reference clearer?}

    \begin{align*}
      &\LetB 42 \In                       \\
      &\ \ \LetB \DeBruijn{0} + 6 \In     \\
      &\ \ \ \ \LetB \DeBruijn{0} + 7 \In \\
      &\ \ \ \ \ \ \DeBruijn{2}
    \end{align*}

    This makes $\alpha$-equivalence of expressions trivial and avoids variable capture,
    but there are still opportunities for mistakes during transformations.
    Adding or removing a binding
    requires us to traverse the binding's body and add or subtract 1 from all its free variables.
    We can see this in our example when removing the innermost (unused) let-binding:

    \begin{align*}
      &\LetB 42 \In                   \\
      &\ \ \LetB \DeBruijn{0} + 6 \In \\
      &\ \ \ \ \DeBruijn{1}
    \end{align*}

    While useful for machines, this representation can be unintuitive for humans to reason about.
    This can be alleviated by formally describing the necessary invariants
    and using tooling to make sure they are upheld.
    We show a possible way of using dependent types to do this in section
    \ref{sec:de-bruijn-intrinsically-typed}.

  \paragraph{co-de-Bruijn Representation}
    Another nameless representation is described by McBride \cite{McBride2018EveryBodysGotToBeSomewhere}.
    Where de Bruijn representation uses references to indicate which of the variables in scope they refer to,
    the co-de-Bruijn way is for each syntax tree node
    to shrink down the context of which variables occur in each subexpression.
    Once a variable occurrence is reached, the context only consists of a single element.
    Introducing or removing a binding can now be done without traversing the expression,
    as we can instead modify the way the context is shrunk down to its \emph{relevant}
    (actually occurring) part.
    We will see further advantages of the co-de-Bruijn approach later.

    This representation and its invariants can be even harder for humans to comprehend.
    McBride writes that
    ``only a fool would attempt to enforce the co-de-Bruijn invariants without support
    from a typechecker''
    and makes heavy use of Agda's dependent type system.
    We follow his approach closely, as shown in section
    \ref{sec:co-de-bruijn-intrinsically-typed}.

  \paragraph{Other Representations}
    There are many other techniques%
    \footnote{
    There is an introductory blogpost
    \cite{Cockx2021RepresentationsBinding}
    comparing options available in Agda.
    }
    such as higher-order abstract syntax
    \cite{Pfenning1988HOAS}
    and also combinations of multiple techniques, e.g. the locally nameless representation
    \cite{Chargueraud2011LocallyNameless}.
