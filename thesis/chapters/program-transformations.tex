\chapter{Program Analysis and Transformation}
\label{ch:program-transformations}

\Draft{
  As a running example, we will consider a simple expression language with let-bindings,
  variables, primitive values (integers and Booleans), and a few binary operators.
  Since the transformations in this thesis primarily relate to variables and binders,
  the choice of possible values and additional primitive operations on them is mostly arbitrary.
  Extending the language with further values and operators is trivial.
  \begin{align*}
    P, Q ::=&\ v
    \\ \big||&\ P + Q
    \\ \big||&\ \Let{x} P \In Q
    \\ \big||&\ x
  \end{align*}

  An expression can be bound to a variable $x$ using a $\textbf{let}$-binding.
  Note that this makes the language equivalent to a restricted version of the simply typed $\lambda$-calculus,
  where $\lambda$-abstraction and application can only occur together as $(\lambda x. Q)\ P$.
  Encapsulating this pattern as $\Let{x} P \In Q$
  simplifies parts of the analysis and
  avoids the need for allowing functions as values.
  \Fixme{We now have $\lambda$-abstractions!}
}

For now we mainly consider transformations aimed at optimising functional programs.
A large number of program analyses and optimisations are presented in the literature
\cite{Nielson1999PrinciplesProgramAnalysis}
\cite{Santos1995CompilationByTransformation}
and used in production compilers such as the Glorious Haskell Compiler (GHC).
We generally focus on those transformations that deal with variable binders,
such as
\emph{inlining},
\emph{let-floating},
\emph{common subexpression elimination} and
\emph{dead binding elimination},
which is explained below.

\section{Dead Binding Elimination}
\label{sec:program-transformations-dbe}
An expression is not forced to make use of the whole context to which it has access.
Specifically, a let-binding introduces a new variable, but it might never be used
in the body.
Consider for example the following expression:
\begin{align*}
  &\Let{x} 42 \In            \\
  &\ \ \Let{y} x + 6 \In     \\
  &\ \ \ \ \Let{z} y + 7 \In \\
  &\ \ \ \ \ \ x
\end{align*}
Here, the binding for $z$ is clearly unused, as the variable never occurs in the body.
Such dead bindings can be identified by \emph{live variable analysis}
and consequently be removed.
\\
Note that $y$ is not needed either: Removing $z$ will make $y$ unused.
Therefore, multiple iterations of live variable analysis and binding elimination might be required.
Alternatively, \emph{strongly live variable analysis} can achieve the same result in a single pass
by only considering variables to be live
if they are used in declarations of variables that are live themselves.

\Fixme{Also mention inlining let-bindings? Not implemented...}

\section{Moving let-bindings}
\label{sec:program-transformations-let-sinking}
Even when a binding cannot be removed,
it can still be beneficial to move it to a different location.
Several such strategies have for example been described and evaluated
in the context of lazy functional programs
\cite{Jones1996LetFloating}.
\\
Of those, we will focus on the \emph{let-sinking} transformation
(called let-floating in the paper).
Generally, the further inward a let binding is moved, the better:
Further optimisations might get unlocked and in the presence of branching,
the binding it might never be executed.
Of course, we must be careful that the binding remains in scope
for all of the variable's occurrences
and consider some exceptions to the heuristic of pushing as far as possible.
We do not want to duplicate the binding
or move it inside a $\lambda$-abstraction, which duplicates work
if evaluated multiple times.

\vspace{1cm}
\OpenEnd{Briefly look at implementing inling and local rewrites?}
